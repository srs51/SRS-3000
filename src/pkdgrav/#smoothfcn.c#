#include <math.h>
#include <assert.h>
#include "smoothfcn.h"
/*DEBUG following functions should be collected somewhere else...*/
int sign(double A);
#define sign(A) ((A)<0.?-1:(A)>0.?1:0)
double min(double A,double B);
#define min(A,B) ((A) > (B) ? (B) : (A))
double max(double A,double B);
#define max(A,B) ((A) > (B) ? (A) : (B))

#ifdef COLLISIONS
#include "ssdefs.h"
#include "collision.h"
#include "polyroots.h"
#endif

#ifdef AGGS
#include "aggs.h"
#endif

#ifdef WALLS
#include "walls.h"
#endif

#ifdef SPRINGS
#include "random.h"
#endif

/*
 Change the way the Balsara Switch is applied:
*/
/*
#define SWITCHCOMBINE(a,b) (0.5*(a->BalsaraSwitch+b->BalsaraSwitch))
#define SWITCHCOMBINE(a,b) (a->BalsaraSwitch > b->BalsaraSwitch ? a->BalsaraSwitch : b->BalsaraSwitch)
#define SWITCHCOMBINE(a,b) (a->BalsaraSwitch*b->BalsaraSwitch)
#define SWITCHCOMBINE(a,b) ((a->BalsaraSwitch*b->BalsaraSwitch > 0.5 || \
           (a->BalsaraSwitch > 0.5 && (dx*a->aPres[0]+dy*a->aPres[1]+dz*a->aPres[2]) > 0) || \
           (b->BalsaraSwitch > 0.5 && (dx*b->aPres[0]+dy*b->aPres[1]+dz*b->aPres[2]) < 0)) ? 1 : 0)
#define SWITCHCOMBINEA(a,b) (a->BalsaraSwitch >= 1 || b->BalsaraSwitch >= 1 ? 1 : 0)
#define SWITCHCOMBINEA(a,b) ((a->BalsaraSwitch*b->BalsaraSwitch)*(a->ShockTracker > b->ShockTracker ? a->ShockTracker : b->ShockTracker))
*/

#define ACCEL(p,j) (((PARTICLE *)(p))->a[j])
#define KPCCM 3.085678e21

#ifdef SHOCKTRACK
/* Shock Tracking on: p->ShockTracker and p->aPres are defined */

#define SWITCHCOMBINE(a,b) (0.5*(a->BalsaraSwitch+b->BalsaraSwitch))
#define SWITCHCOMBINEA(a,b) ((a->BalsaraSwitch*b->BalsaraSwitch)*a->ShockTracker*b->ShockTracker)
#define SWITCHCOMBINEB(a,b) (a->BalsaraSwitch*b->BalsaraSwitch)

#define ACCEL_PRES(p,j) (((PARTICLE *)(p))->aPres[j])
#define ACCEL_COMB_PRES(p,j) ((((PARTICLE *)(p))->a[j])+=(((PARTICLE *)(p))->aPres[j]))

#else

#define SWITCHCOMBINE(a,b) (0.5*(a->BalsaraSwitch+b->BalsaraSwitch))
#define SWITCHCOMBINEA(a,b) SWITCHCOMBINE(a,b)
#define SWITCHCOMBINEB(a,b) SWITCHCOMBINE(a,b)

#define ACCEL_PRES(p,j) (((PARTICLE *)(p))->a[j])
#define ACCEL_COMB_PRES(p,j) 

#endif

#ifdef PEAKEDKERNEL
/* Standard M_4 Kernel */
#define BALL2(a) ((a)->fBall2)
#define KERNEL(ak,ar2) { \
		ak = 2.0 - sqrt(ar2); \
		if (ar2 < 1.0) ak = (1.0 - 0.75*ak*ar2); \
		else ak = 0.25*ak*ak*ak; \
        }
#define DKERNEL(adk,ar2) { \
		adk = sqrt(ar2); \
		if (ar2 < 1.0) { \
            if (adk < 2./3.) { \
               if (adk > 0) adk = -1/adk; \
			   } \
form on neighbor's call if neighbor has lower iOrder number or skip if neighbor is particle */
		if (p->iOrder >= pn->iOrder) /*DEBUG could check if pn->iOrder == p->iOrder right at the start...*/
			continue;

		/* check to see if particle is overlapping with neighbor */
		mdlassert(smf->pkd->mdl,nnList[j].fDist2 > 0.0);

		r2 = RADIUS(pn);
#ifdef GLASS_BEADS
		SPRING *ps;
		double dConjoinedSize;
		for (i=0;i<MAX_NUM_SPRINGS_PER_PARTICLE;i++) { /* might save time by only doing this loop once to find the spring (another springs loop below) */
			ps = &p->springs[i];
			if (ps->iOrder == pn->iOrder && ps->fZeroStrainLength == 0. && ps->fStressLimit < 0) {
				dConjoinedSize = ps->fStressLimit; /* separation between centers at time of tangential fracture */
				r1 = -r1*dConjoinedSize/(r1 + r2); /*DEBUG:check this for KE gain*/
				r2 = -r1 - dConjoinedSize;
				r1sq = r1*r1;
				}
			break;
			}
#endif /* GLASS_BEADS */
		if ((r1 + r2)*(r1 + r2) > nnList[j].fDist2)
			bApplyForce = 1;

#ifdef CHARGE
		if (bApplyForce)
			_do_charge_xfer(p,r1,r2);
#endif /* CHARGE */

		for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE;i++) {
			pe = &p->overlaps[i];
			if (pe->iOrder == pn->iOrder) {
				mdlassert(smf->pkd->mdl,!bFoundNbr); /* ensure no duplicate overlaps */
				bFoundNbr = 1;
				iOverlap = i;
				}
			}

		/* four cases: */
		if (bFoundNbr && bApplyForce) {
			pe = &p->overlaps[iOverlap];
#ifndef DEM_TWOLAYERS
			++pe->liOverlapCounter; /* if two layers, take care of the counter once determined which layer we're in */
#endif
			}

		else if (bFoundNbr && !bApplyForce) {
			pe = &p->overlaps[iOverlap];
#ifdef OVERLAP_OUTPUT
			fprintf(overlapOUT,"%g %d %d %li %e\n",smf->dTime,p->iOrder,pe->iOrder,pe->liOverlapCounter,x_max[p->iOrder][j]);
			x_max[p->iOrder][j] = 0.;
#endif /* OVERLAP_OUTPUT */
			pe->iOrder = -1;
			vectorZero(pe->vShear);
			vectorZero(pe->vnOld);
			pe->liOverlapCounter = 0; /* could insert warning here before reset if liOverlapCounter is "low" */
			continue;
			}

		else if (!bFoundNbr && bApplyForce) {
			for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE;i++) {
				pe = &p->overlaps[i];
				if (pe->iOrder == -1) {
					iOverlap = i;
					pe->iOrder = pn->iOrder;
					vectorZero(pe->vShear);
					vectorZero(pe->vnOld);
#ifndef DEM_TWOLAYERS
					pe->liOverlapCounter = 1; /* if two layers, take care of the counter once determined which layer we're in */
#endif
					break;
					}
				}
			mdlassert(smf->pkd->mdl,i < MAX_NUM_OVERLAPS_PER_PARTICLE); /* ensure free spot was indeed found and used */
			}
		else if (!bFoundNbr && !bApplyForce)
			continue;

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"Starting force calculation on neighbor: iOrder = %i(%i), neighbor = %i, neighbor in DEM struct = %i\n",p->iOrder,smf->pkd->idSelf,pn->iOrder,pe->iOrder);

		mdlassert(smf->pkd->mdl,iOverlap >= 0 && iOverlap < MAX_NUM_OVERLAPS_PER_PARTICLE);

		pe = &p->overlaps[iOverlap]; /* pe now points to the overlap of this particle and its neighbor */

		m1 = p->fMass;
		m2 = pn->fMass;
		if (r1 == r2)
			r2sq = r1sq;
		else
			r2sq = r2*r2;

#ifdef AGGS
		if (IS_AGG(p))
			m1 = p->fMassAgg;
		if (IS_AGG(pn))
			m2 = pn->fMassAgg;
#endif /* AGGS */

#ifdef WALLS
		if (PARTICLE_STUCK(p))
			dReducedMass = m2;
		else if (PARTICLE_STUCK(pn))
			dReducedMass = m1;
		else
#endif /* WALLS */

		if (m1 == m2) /* save time if masses are equal */
			dReducedMass = 0.5*m1;
		else
			dReducedMass = m1*m2/(m1 + m2);
		dSqrtReducedMass = sqrt(dReducedMass);
		d = sqrt(nnList[j].fDist2);
		if (r1 == r2) /* save time if radii are equal */
			l1 = l2 = 0.5*d;
		else {
			l1 = (r1sq - r2sq + nnList[j].fDist2)/(d + d);
			l2 = d - l1;
			mdlassert(smf->pkd->mdl,l1 >= 0.0 && l2 >= 0.0);
			}
		x = r1 + r2 - d;
		mdlassert(smf->pkd->mdl,x >= 0.0);
#ifdef DEM_TWOLAYERS /* if an inner boundary is defined where stiffness changes */
		if (r1 == r2) /* save time if radii are equal */
			dEffRad = r1;
		else
			dEffRad = 0.5*(r1 + r2);
		dInBnd = dEffRad*dInBndFrac;
		if (x > dInBnd) {
			kn = kn_inner;
			kt = kt_inner;
			x_inner = x - dInBnd;
			mdlassert(smf->pkd->mdl,x_inner >= 0.0);
			F_outershell = dInBnd*kn_outer;
			if (pe->liOverlapCounter <= 0)
				--pe->liOverlapCounter;
			else { /* scale static spring if boundary layer was just crossed (conserve energy in tang spring: 1/2 kt*(vShear)^2 */
#ifdef OVERLAP_OUTPUT
				fprintf(overlapOUT,"inner boundary crossed - %g %d %d %li %e\n",smf->dTime,p->iOrder,pe->iOrder,pe->liOverlapCounter,x_max[p->iOrder][j]);
#endif
				vectorScale(pe->vShear,sqrt(kt_outer/kt_inner),pe->vShear); /* vnOld remains the same */
				pe->liOverlapCounter = -1;
				}
			}
		else {
			kn = kn_outer;
			kt = kt_outer;
			x_inner = -1.;
			F_outershell = 0.;
			if (pe->liOverlapCounter >= 0)
				++pe->liOverlapCounter;
			else { /* scale static spring... */
#ifdef OVERLAP_OUTPUT
				fprintf(overlapOUT,"inner boundary crossed - %g %d %d %li %e\n",smf->dTime,p->iOrder,pe->iOrder,pe->liOverlapCounter,x_max[p->iOrder][j]);
#endif
				vectorScale(pe->vShear,sqrt(kt_inner/kt_outer),pe->vShear);
				pe->liOverlapCounter = 1;
				}
			}
#endif /* DEM_TWOLAYERS */

#ifdef OVERLAP_OUTPUT
		if (x > x_max[p->iOrder][j])
			x_max[p->iOrder][j] = x;
#endif /* OVERLAP_OUTPUT */

		{
		int iWarningType = DEM_NOERR;
		if ((x > smf->FO.DP.dErrorFrac*r1) || (x > smf->FO.DP.dErrorFrac*r2))
			iWarningType = DEM_ERROR;
		else if ((x > smf->FO.DP.dMajorFrac*r1) || (x > smf->FO.DP.dMajorFrac*r2))
			iWarningType = DEM_MAJOR;
		else if ((x > smf->FO.DP.dMinorFrac*r1) || (x > smf->FO.DP.dMinorFrac*r2))
			iWarningType = DEM_MINOR;
		/*
			  printf("%e %e %e\n",vectorMag(p->v),vectorMag(p->w),pe->S
		*/
					 
		if (iWarningType != DEM_NOERR) {
#if (INTERNAL_WARNINGS != 0)
			static int nWarn = 1;
#ifndef GLASS_BEADS
			if (nWarn == 1 || nWarn%INTERNAL_WARNINGS == 0 || iWarningType != DEM_MINOR)
				(void) fprintf(stderr,"DEM WARNING #%i (pid=%i) [T=%g]: %s: %i onto %i is %f%%, %i onto %i is %f%%\n",
							   nWarn,smf->pkd->idSelf,smf->dTime,iWarningType == DEM_MINOR ? "minor overlap" :
							   iWarningType == DEM_MAJOR ? "major overlap" : "overlap error",p->iOrder,pe->iOrder,
							   100.*x/r1,pe->iOrder,p->iOrder,100.*x/r2); /* note: 200% ==> complete overlap for r1=r2... */
#endif
			++nWarn;
#endif /* INTERNAL_WARNINGS */
				mdlassert(smf->pkd->mdl,iWarningType != DEM_ERROR);
			    }
			}
 
		a = 1./d;
		vectorSet(n,-nnList[j].dx*a,-nnList[j].dy*a,-nnList[j].dz*a); /* sign: n[i] = unit vector of [rn - r], points from particle's center toward neighbor's center */

		vectorCross(p->wPred,n,s1);
		vectorCross(pn->wPred,n,s2);
		vectorScale(s1,l1,s1);
		vectorScale(s2,-l2,s2);

		Un = Ut = Rt = 0.;
		if (mu_r != 0.) {
			for (i=0;i<3;i++)
				v[i] = pn->vPred[i] - p->vPred[i]; /*DEBUG! is this correct for SLIDING_PATCH?*/
#ifdef SLIDING_PATCH
			if (smf->PP.bPatch) {
				/* adjust neighbor y-velocity if it's a ghost! */
				/* note: DEM uses pn->v - p->v while collisions does the opposite, so the sign of the adjustment to v[1] is swapped below... */
				if (p->r[0] > pn->r[0] && nnList[j].dx < 0.0)
					v[1] -= 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
				else if (p->r[0] < pn->r[0] && nnList[j].dx > 0.0)
					v[1] += 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
				}
#endif /* SLIDING PATCH */
			for (i=0;i<3;i++) {
				s[i] = s2[i] - s1[i];
				r[i] = s2[i] + s1[i]; /* rolling */
				u[i] = v[i] + s[i];
				Un += u[i]*n[i];
				}

			for (i=0;i<3;i++) {
				un[i] = Un*n[i];
				ut[i] = u[i] - un[i];
				Ut += ut[i]*ut[i];
				Rt += r[i]*r[i]; /* rolling */
				}
			Ut = sqrt(Ut);
			Rt = sqrt(Rt);
			}
		else { /* let's make 2 functions in dem.c that do this dependent on mu_r == 0? to clean this up [srs] */
			for (i=0;i<3;i++)
				v[i] = pn->vPred[i] - p->vPred[i]; /*DEBUG! is this correct for SLIDING_PATCH?*/
#ifdef SLIDING_PATCH
			if (smf->PP.bPatch) {
/*DEBUG! if (p->iOrder == 89773) fprintf(stderr,"*** %i vpred  = %23.16e,%23.16e,%23.16e\n",p->iOrder,p->vPred[0],p->vPred[1],p->vPred[2]);*/
/*DEBUG! if (p->iOrder == 89773) fprintf(stderr,"*** %i vnpred = %23.16e,%23.16e,%23.16e\n",p->iOrder,pn->vPred[0],pn->vPred[1],pn->vPred[2]);*/
/*DEBUG! if (p->iOrder == 89773) fprintf(stderr,"*** %i v before = %23.16e,%23.16e,%23.16e\n",p->iOrder,v[0],v[1],v[2]);*/
				/* adjust neighbor y-velocity if it's a ghost! */
				if (p->r[0] > pn->r[0] && nnList[j].dx < 0.0)
					v[1] -= 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
				else if (p->r[0] < pn->r[0] && nnList[j].dx > 0.0)
					v[1] += 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
				}
#endif /* SLIDING PATCH */
			for (i=0;i<3;i++) {
				s[i] = s2[i] - s1[i];
				u[i] = v[i] + s[i];
				Un += u[i]*n[i];
				}

			for (i=0;i<3;i++) {
				un[i] = Un*n[i];
				ut[i] = u[i] - un[i];
				Ut += ut[i]*ut[i];
				}
			Ut = sqrt(Ut);
/*DEBUG! if (p->iOrder == 89773) fprintf(stderr,"*** %i v after = %23.16e,%23.16e,%23.16e\n",p->iOrder,v[0],v[1],v[2]);*/
/*DEBUG! if (p->iOrder == 89773) fprintf(stderr,"*** %i un = %23.16e,%23.16e,%23.16e\n",p->iOrder,un[0],un[1],un[2]);*/
			}

		/* unit tangential velocity vector (ensure that this is needed, also want a un and unPred... - [srs]) */
		if (Ut != 0.0)
			vectorScale(ut,1./Ut,t);
		else
			vectorZero(t); /* avoid dividing by zero */

		/*
		** relative to neighbor - i.e. in frame where velocity at contact point of particle
		** is zero, this is the tangential velocity at the contact point of neighbor
		*/

		/* unit rolling vector */
		if (Rt != 0.0)
			vectorScale(r,1./Rt,rt); /* rt[i] = unit vector of velocity of spinning component at contact point */
		else /* save time and avoid dividing by zero */
			vectorZero(rt);

		/* damping terms */

#ifndef DEM_TWOLAYERS
		Cn = CnPreFac*dSqrtReducedMass;
		Ct = CtPreFac*dSqrtReducedMass; /* ...relating dEpsN,dEpsT to Cn,Ct comes from Cleary etal. '98 */
#else  /* if an inner boundary is defined where stiffness changes */
		if (x > dInBnd) {
			Cn = CnInnerPreFac*dSqrtReducedMass;
		   	Ct = CtInnerPreFac*dSqrtReducedMass;
			}
		else {
			Cn = CnOuterPreFac*dSqrtReducedMass;
		   	Ct = CtOuterPreFac*dSqrtReducedMass;
			}
#endif /* DEM_TWOLAYERS */

		/*
		** In the following, if a particle is stuck, its corresponding
		** mass and inertia moment should be infinite, and a and b
		** zero, but we don't actually use these values if the
		** particle is stuck, so it's ok (if inefficient).  It would be
		** straightforward to skip the corresponding calculations in
		** such a case, but perhaps too messy!
		*/

		a1 = 1./m1;
		i1 = 0.4*m1*r1sq;
		b1 = 1./i1;

		/* NOTE: should put in a switch of some sort here based upon which of mu_s, mu_r, and mu_t are defined */

		if (m1 == m2) { /* save time if masses are equal */
			a2 = a1;
			if (r1 == r2) { /* save time if both masses and radii are equal */
				i2 = i1;
				b2 = b1;
				}
			else {
				i2 = 0.4*m2*r2sq;
				b2 = 1./i2;
				}
			}
		else {
			a2 = 1./m2;
			i2 = 0.4*m2*r2sq;
			b2 = 1./i2;
			}

		/* Begin Hack to save time for mu_s == 0.
		if (mu_s == 0.) {
			for (i=0;i<3;i++) Fn[i] = -kn*x*n[i] + Cn*un[i];
			vectorZero(Ft);
			vectorZero(Ftn);
			}
			else { */
		/* End Hack to save time for mu_s == 0. */

		/* Tangential displacement vector */
		
		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"Starting calculation on tangential displacement vector: iOrder = %i(%i), neighbor = %i\n",p->iOrder,smf->pkd->idSelf,pe->iOrder);

		if (vectorMagSq(pe->vnOld) != 0.0) {
#ifndef DEM_TWOLAYERS /* if boundary is crossed, vnOld will be defined and |liOverlapCounter| == 1 */
			mdlassert(smf->pkd->mdl,pe->liOverlapCounter > 1); /* should not be first step in overlap */
#endif

			/*
			** What we really would want here is to track the motion of a
			** point between the current contact point and the equilibrium
			** contact point, then use the changes in the motion and
			** orientation of that point to determine the direction and
			** magnitude of the vector that points from the current
			** contact point to the equilibrium contact point (or vice
			** versa). For example, if one particle twists around the
			** current normal, but the other particle does not exhibit
			** this twisting relative to the motion at the midpoint, then
			** this other particle's equilibrium contact point should
			** really not change, though it would feel the compulsion to
			** rotate around its equilibrium contact point (where its
			** neighbor is).
			**
			** We'll take an approximation, both that the tangential
			** displacements stay small, and that contacts don't last long
			** compared to the motions of the particles (and where they
			** do, as in the case of grains grinding against one another,
			** they might exhibit some creep).
			*/

			/*
			** Either store this stuff in memory the previous step (current implemenation),
			** or at the very least ensure only computing vPrOld once per particle
			** If vnOld is not stored in the DEM element struct, we need to compute it somehow,
			** this would be an example of how to start:

			for (i=0;i<3;i++) {
				vPrOld[i] = p->r[i] - p->v[i]*dDelta;
				vPnrOld[i] = pn->r[i] - pn->v[i]*dDelta;
				vnOld[i] = vPnrOld[i] - vPrOld[i];
				}

			vectorNorm(vnOld); // sign: vnOld = unit vector of [vPrnOld - vPrOld], points from particle's center toward neighbor's center
			*/

			/*
			** We first consider rotation around the normal - for this,
			** one approach is to simply rotate the tangential spring
			** around the normal (we'll use the previous normal, vnOld) by
			** the average amount that the two particles rotated around
			** vnOld in the previous step. However, intuitively, there are
			** drawbacks, especially in the case of particles interacting
			** with stationary wall faces.
			*/

			/*
			** vDum below will be the average of the spins of the two particles from 1/2 step ago, midway through the previous full drift
			** step, because we want to know the amount of rotation taken around the normal over the last step.  Thus we use the spins
			** from the midpoint.
			**
			** Then we perform rotation of vShear around the normal at the midpoint between the previous step and this step by first taking
			** an average of n-hat and the old n-hat (vnOld).  vDum2 below is this normalized vector.
			*/
			  
			vectorAdd(p->w,pn->w,vDum);
			vectorAdd(pe->vnOld,n,vDum2);
			vectorNorm(vDum2);

			/* could consider checking that this is nonzero before expensive next op, but only in special cases will it be nonzero... */
			vectorRotate(pe->vShear,vDum2,0.5*dDelta*vectorDot(vDum,vDum2));

			/*
			** Next, we change the orientation of the displacement vector
			** in the same way that the orientation of the normal has
			** changed over the previous step, and assume that the normal
			** did not change by more than 90 degrees.
			*/

			/*
			vectorScale(n,vectorDot(n,pe->vShear),vDum);
			vectorSub(pe->vShear,vDum,vDum);
			if ((a = vectorMagSq(vDum)) != 0.0)
				vectorScale(vDum,sqrt(vectorMagSq(pe->vShear)/a),pe->vShear);
			*/

			vectorCross(pe->vnOld,n,vDum); // axis of rotation (not normalized)
			if ((a = vectorMagSq(vDum)) != 0.0) {
				a = sqrt(a);
				vectorScale(vDum,1./a,vDum);
				vectorRotate2(pe->vShear,vDum,a,vectorDot(n,pe->vnOld)); // converting to an angle and using vectorRotate() failed when recomputing the sin and cos
				}
			}
 
		/* set vnOld to current n for use in next step in the case that the overlap persists to the next step */
		vectorCopy(n,pe->vnOld);

		N = T = 0.0; /* normal, tangential forces (scalar) */
 
#ifdef DEM_TWOLAYERS
		if (x_inner >= 0.0)
			x = x_inner; /* if an inner boundary is defined where stiffness changes and is penetrated */
#endif

		for (i=0;i<3;i++) { /*DEBUG: optimize this function for cases when !dMuS)*/
			pe->vShear[i] += ut[i]*dDelta; /* this step's contribution to the tangential spring */
			Fn[i] = -(kn*x + F_outershell)*n[i] + Cn*un[i]; /* check to ensure that all other forces are computed first (e.g. gravity) */
			Ft[i] = kt*pe->vShear[i] + Ct*ut[i]; /*      ""      */
			N += Fn[i]*Fn[i]; /* square of normal force */
			T += Ft[i]*Ft[i]; /* square of tangential force */
			}
			
		/* Glass Beads Hack */
#ifdef _GLASS_BEADS/*DEBUG: old version - for now, skip what is just below and simply break spring in the case that static friction is exceeded (further down) */
		/*
		** hack for DEM with SPRINGS: if there is a spring connecting
		** the particles and the DEM tangential stress exceeds (1/3 ?)
		** the (normal) spring stress limit, then break the spring.
		*/

		static const double dConvert = (1.49597870e11/1.9891e30*(365.25*24*3600)*(365.25*24*3600)/(2.0*M_PI)/(2.0*M_PI)); /* Pascals --> pkdgrav units (multiply) [1.897217e-06] */
		SPRING *ps;
		double dBending_sq = 1./mu_s/mu_s; /* how many times stronger tensile strength is over shear strength squared */
		for (i=0;i<MAX_NUM_SPRINGS_PER_PARTICLE;i++) {
			ps = &p->springs[i];
			if (ps->iOrder == pn->iOrder && ps->fZeroStrainLength > 0.) {
				a = ps->fStressLimit*dConvert*M_PI*0.5*(r1 + r2)*0.5*(r1 + r2)*smf->FO.SP.dPorosityFactor;
				if (dBending_sq*T > a*a) {
					ps->fZeroStrainLength = 0.; /* Break this link */
					printf("SPRING BROKEN VIA DEM TANGENTIAL EXTENSION (%i & %i)\n",p->iOrder,ps->iOrder);
					}
				}
			}
#endif /* _GLASS_BEADS */

		F2 = N*mu_s*mu_s; /* square of max allowed static friction */
		N = sqrt(N); /* N is now defined as the normal force (not squared) */
#ifdef DEM_PRESSURE
		p->dPressure += N; /*DEBUG: hack to sum total pressure on particle*/
		pn->dPressure += N; /*DEBUG: hack to sum total pressure on neighbor*/
#endif

		/*DEBUG*/
		/*
		printf("DoDEM() call = %d neighbor = %d pe->liOverlapCounter = %li x/r = %e N = %e |S|/r = %e S/|S| dot n = %e\n",count,pn->iOrder,pe->liOverlapCounter,x/r1,N,vectorMag(pe->vShear)/r2,vectorDot(pe->vShear,n)/vectorMag(pe->vShear));
		printf("S[0]/r = %e t[0] = %e  ;  F = %e  ;  Ct*Ut = %e  ;  Ft[0] = %e p->w[0] = %e\n",pe->vShear[0]/r1,t[0],sqrt(F2),Ct*Ut,Ft[0],p->w[0]);
		printf("S[1]/r = %e t[1] = %e  ;  b1 = %e  ;  Ct*Ut = %e  ;  Ft[1] = %e p->w[1] = %e\n",pe->vShear[1]/r1,t[1],b1,Ct*Ut,Ft[1],p->w[1]);
		printf("S[2]/r = %e t[2] = %e  ;  l1 = %e  ;  Ct*Ut = %e  ;  Ft[2] = %e p->w[2] = %e\n",pe->vShear[2]/r1,t[2],l1,Ct*Ut,Ft[2],p->w[2]);
		*/

		if (F2 < T) {
			if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"Static friction limit exceeded: iOrder = %i(%i), neighbor = %i\n, tangential force = %.16e, limit = %.16e\n",p->iOrder,smf->pkd->idSelf,pe->iOrder,sqrt(T),sqrt(F2));

			/* Glass Beads Hack */
#ifdef GLASS_BEADS/*DEBUG*/
			/*
			** hack for DEM with SPRINGS: if there is a spring connecting the
			** particles and the static limit is exceed, then break the spring.
			*/

			SPRING *ps;
			int bSpringJustBroken;
			bSpringJustBroken = 0;
			for (i=0;i<MAX_NUM_SPRINGS_PER_PARTICLE;i++) {
				ps = &p->springs[i];
				if (ps->iOrder == pn->iOrder && ps->fZeroStrainLength != 0.) {
					ps->fZeroStrainLength = 0.; /* Break this link */
					/*DEBUG:
					** the following line is a hack to save the distance when the spring broke. done to mitigate that fact that after a spring
					** breaks due to tangential forces, particles can find themselves in overlap and subject to significant DEM repulsive forces,
					** which is not desirable. also note that this will not get saved in *.spr files (but _probably_ in *.chk files).
					*/
					ps->fStressLimit = -d;
					bSpringJustBroken = 1;
					printf("SPRING BROKEN VIA DEM TANGENTIAL EXTENSION (%i & %i)\n",p->iOrder,ps->iOrder);
					}
				}
			if (bSpringJustBroken) continue; /* skip the DEM force calculation between this particle and its neighbor */
#endif /* GLASS_BEADS */
			/*
			** Once static friction is exceeded:
			** scale vShear to make Ft = dTangentialSpringDrag*F*Ft-hat with the new vShear-hat = Ft-hat,
			** where Ft-hat will be some linear combination of the prior vShear-hat and the current t.
			**
			** for dTangentialSpringDrag = 1, once slippage occurs, strain is reset to a value such that:
			**   tangential restoring force
			** + tangential damping force
			** + other tangential forces (e.g. grav)
			**   --------------------------------------------
			** = maximum frictional force (mu_s*Normal Force)
			**
			** Let's clarify:
			** In the case of F < Ct*Ut (tangential kinetic damping exceeds max allowed static friciton):
			**    Ft[i] = F*t[i].
			**
			** In the case of F > Ct*Ut (tangential kinetic damping does not exceed max allowed static friciton, but F < Ct*Ut + kt*vShear):
			**    Ft[i] = Ct*ut[i] + dTangentialSpringDrag*(F - Ct*Ut)*vShear-hat[i].
			**
			** Then we reset vShear to be equal to the second argument on the right side of the above equation
			** divided by kt and re-oriented in the direction of Ft, as determined by the above equation.
			** (Or simply zeroed in the former case of F < Ct*Ut.)
			**
			** Note that |Ft| will be F either if Ct*Ut > N or if dTangentialSpringDrag = 1.
			** In all other cases, some degree of slip-stick behavior will be exhibited.
			*/

			F = N*mu_s; /* max allowed static friction (not squared) */
			if (dTangentialSpringDrag != 0.0) {

				/* compute the new magnitude of vShear, but if tangential kintetic friction alone exceeds static friction, vShear will be zeroed */
				a = F - Ct*Ut;
				b = a <= 0. ? 0. : vectorMag(pe->vShear);
				a = b <= 0. ? 0. : dTangentialSpringDrag*a/(kt*b);

				/* set vShear */
				vectorScale(pe->vShear,a,pe->vShear); /* vShear for this step */
				vectorScale(t,min(F,Ct*Ut),vDum); /* the force due to tangential kinetic friction */
				vectorScale(pe->vShear,kt,vDum2);
				vectorAdd(vDum,vDum2,vDum); /* total tangential force due to both static and kinetic friction */

				mdlassert(smf->pkd->mdl,T > 0.);
				if (a)
					vectorScale(Ft,a*b/sqrt(T),pe->vShear);
				else
					vectorZero(pe->vShear);					
				vectorCopy(vDum,Ft);
				}

			else {
				vectorZero(pe->vShear);
				vectorScale(t,min(F,Ct*Ut),Ft);
				}
			}
		vectorCross(Ft,n,Ftn); /* tangential DEM induced torque per unit length */
		/* Begin Hack to save time for mu_s == 0. */
		/*	}*/
		/* End Hack to save time for mu_s == 0. */

		if (Rt != 0.) /* Rt always zero if mu_r is zero (above), so !Rt condition is better here */
			dRollingFriction = mu_r*N;
		else
			dRollingFriction = 0.;

		/* Below, we use "twisting friction" to damp out spin along the normal axis connecting the particles' centers */
		if (mu_t != 0.) {

			/* make [dTwistRate * n-hat] be the relative differential spin around normal axis: */
			vectorSub(pn->wPred,p->wPred,vDum);
			dTwistRate = vectorDot(vDum,n);

			dContactRadius = sqrt(r1sq - l1*l1);
			dTwistingFriction = mu_t*N*sign(dTwistRate);

			/* alternate damping method, [Cn]*[contact area]*[differential spin]*n-hat, may want "angular" spring for this implementation */

			/* vectorScale(n,Cn*a*bb,vTfn); */
			/* above, a is contact area of interaction (this is the area inside a circle drawn by the overlap at particle surfaces, with contact point at center) */
			}

		/* moments (tangential DEM torque per unit length computed above) */
		if (Rt != 0.) {
			vectorCross(rt,n,vDum); /* unit vector giving angular direction of rolling friction torque */
			vectorScale(vDum,dRollingFriction,vRft); /* rolling friction torque per unit length */
			/* below we check to see if rolling friction impulse is greater than rolling momentum. if so, make equal */
			a = vectorMagSq(vRft);
			b = dDelta*(b1*l1*l1 + b2*l2*l2);
			b *= a*b;
			//			printf("%e %e %e %e %e %e %e\n",Rt,dDelta*b1*vRft[0],sqrt(a),dDelta*b1*dDelta*b1*a,b,vectorMag(p->w)*d,vectorMag(p->wPred)*d);
			if (Rt*Rt < b) {
				vectorScale(vRft,(vectorMag(p->w)*l1 + vectorMag(pn->w)*l2)/sqrt(b),vRft);
				//				printf("geraldine ferraro %e\n",vRft[0]);
				}
			}
		else
			vectorZero(vRft);
		if (mu_t != 0.)
			vectorScale(n,dContactRadius*dTwistingFriction,vTfn); /* twisting friction torque */
		else
			vectorZero(vTfn);

		/* apply forces, torques */

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"applying forces and moments: iOrder = %i(%i), neighbor = %i\n",p->iOrder,smf->pkd->idSelf,pe->iOrder);
#ifdef WALLS
		for (i=0;i<3;i++) {
			if (!PARTICLE_STUCK(p)) {
				p->dDeltaAccel[i] += a1*(Fn[i] + Ft[i]);
				p->wDot[i] -= b1*(l1*(Ftn[i] - vRft[i]) - vTfn[i]);
				}
			if (!PARTICLE_STUCK(pn)) {
				pn->dDeltaAccel[i] -= a2*(Fn[i] + Ft[i]);
				pn->wDot[i] -= b2*(l2*(Ftn[i] + vRft[i]) + vTfn[i]);
				}
			}
		/*DEBUG!{
			double FnMag,FtMag;
			FnMag = a1*sqrt(Fn[0]*Fn[0] + Fn[1]*Fn[1] + Fn[2]*Fn[2]);
			FtMag = a1*sqrt(Ft[0]*Ft[0] + Ft[1]*Ft[1] + Ft[2]*Ft[2]);
			if (FnMag > 2000 || FtMag > 2000)
				printf("SOUND %e %i %i %g %g\n",
					   smf->dTime,p->iOrder,pn->iOrder,FnMag,FtMag);
					   }*/
#else /* !WALLS */
		for (i=0;i<3;i++) {
			p->dDeltaAccel[i] += (Fn[i] + Ft[i])*a1;
			p->wDot[i] -= b1*(l1*(Ftn[i] - vRft[i]) - vTfn[i]);
			pn->dDeltaAccel[i] -= (Fn[i] + Ft[i])*a2;
			pn->wDot[i] -= b2*(l2*(Ftn[i] + vRft[i]) + vTfn[i]);
			}
#endif /* WALLS */
#ifdef GLASS_BEADS /* for safety */
		r1 = RADIUS(p);
		r1sq = r1*r1;
#endif
		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"particle-particle forces and moments applied: iOrder = %i(%i), neighbor = %i, current tally of particle force: %.16e, moment: %.16e, neighbor force: %.16e, moment: %.16e\n",p->iOrder,smf->pkd->idSelf,pe->iOrder,vectorMag(p->dDeltaAccel),vectorMag(p->wDot),vectorMag(pn->dDeltaAccel),vectorMag(pn->wDot));
		}

#ifdef WALLS
	if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"beginning particle-walls calculations: iOrder = %i(%i)\n",p->iOrder,smf->pkd->idSelf);
	if (PARTICLE_STUCK(p))
		return; /* skip walls portion of DoDEM() if particle is stuck to any wall */

#ifdef WALLS_REACT
	p->dZForceOnWalls = 0.0; /* reset tally of force from particle onto non-infinitely massive wall(s assemblege) */
#endif

	DEM_ELEMENT *we;
	WALL_PARAMS *WP = &smf->WP;
	WALL *w;
	WALL_DATA *wd;
	double a3,dRadius,dRadNarrow,dLength,dTaper,dOpenAngle,dAngle;
	Vector O,q,vDum3,v1,v2,vVinyl;
	Matrix A;
	static double CnPreFacWalls[MAX_NUM_WALLS],CtPreFacWalls[MAX_NUM_WALLS];

#ifdef DEM_TWOLAYERS
	static double CnOuterPreFacWalls[MAX_NUM_WALLS],CtOuterPreFacWalls[MAX_NUM_WALLS],CnInnerPreFacWalls[MAX_NUM_WALLS],CtInnerPreFacWalls[MAX_NUM_WALLS];
#endif

	/* check to see if particle is overlapping with wall boundaries */

	/* loop over walls */
	for (j=0;j<WP->nWalls;j++) {
		w = &WP->pWalls[j]; /* wall */
		wd = &w->wd; /* wall's data struct */

		/*
		if (p->iOrder == 0) printf("nWalls: %d\ni: %d\niWallID: %d\niType: %d\nvOrigin: %e, %e, %e\nvOrient: %e, %e, %e\nvVertex1: %e, %e, %e\nvVertex2: %e, %e, %e\nvVel: %e, %e, %e\ndOscAmp: %e\ndOscFreq: %e\nvOscVec: %e, %e, %e\ndRadius: %e\ndHoleRadius: %e\ndLength: %e\ndTaper: %e\ndOpenangle: %e\ndAngSpeed: %e\ndEpsN: %e\ndEpsT: %e\niColor: %d\ndTrans: %e\nvOscVel: %e, %e, %e\nvTravel: %e, %e, %e\nvTotVel: %e, %e, %e\n",WP->nWalls,j,w->iWallID,w->wd.iType,w->wd.vOrigin[0],w->wd.vOrigin[1],w->wd.vOrigin[2],w->wd.vOrient[0],w->wd.vOrient[1],w->wd.vOrient[2],w->wd.vVertex1[0],w->wd.vVertex1[1],w->wd.vVertex1[2],w->wd.vVertex2[0],w->wd.vVertex2[1],w->wd.vVertex2[2],w->wd.vVel[0],w->wd.vVel[1],w->wd.vVel[2],w->wd.dOscAmp,w->wd.dOscFreq,w->wd.vOscVec[0],w->wd.vOscVec[1],w->wd.vOscVec[2],w->wd.dRadius,w->wd.dHoleRadius,w->wd.dLength,w->wd.dTaper,w->wd.dOpenAngle,w->wd.dAngSpeed,w->wd.dEpsN,w->wd.dEpsT,w->wd.iColor,w->wd.dTrans,w->vOscVel[0],w->vOscVel[1],w->vOscVel[2],w->vTravel[0],w->vTravel[1],w->vTravel[2],w->vTotVel[0],w->vTotVel[1],w->vTotVel[2]);
		wd->vVel[2] += 1.;
		*/

		if (wd->iType != WallPlane && wd->iType != WallDisk && wd->iType != WallRectangle &&
		    wd->iType != WallTriangle && wd->iType != WallCylinderInfinite &&
		    wd->iType != WallCylinderFinite && wd->iType != WallShell)
			mdlassert(smf->pkd->mdl,0);

		dEpsN = wd->dEpsN;
		dEpsT = wd->dEpsT;
		if (wd->dKn == 0.) /* kn */
			kn = smf->FO.DP.dKn;
		else
			kn = wd->dKn;
		if (wd->dKt == 0.) /* kt */
			kt = smf->FO.DP.dKt;
		else
			kt = wd->dKt;
#ifdef DEM_TWOLAYERS
		if (wd->dKnOuter == 0.) /* kn_outer */
			kn_outer = smf->FO.DP.dKnOuter;
		else
			kn_outer = wd->dKnOuter;
		if (wd->dKtOuter == 0.) /* kt_outer */
			kt_outer = smf->FO.DP.dKtOuter;
		else
			kt_outer = wd->dKtOuter;
		if (wd->dKnInner == 0.) /* kn_inner */
			kn_inner = smf->FO.DP.dKnInner;
		else
			kn_inner = wd->dKnInner;
		if (wd->dKtInner == 0.) /* kt_inner */
			kt_inner = smf->FO.DP.dKtInner;
		else
			kt_inner = wd->dKtInner;
		if (wd->dInnerOverlapBoundary == -1.)
			dInBndFrac = smf->FO.DP.dInnerOverlapBoundary; /* take from ss.par */
		else
			dInBndFrac = wd->dInnerOverlapBoundary;
#endif /* DEM_TWOLAYERS */
		if (wd->dMuS == -1.) /* mu_s */
			mu_s = smf->FO.DP.dMuS;
		else
			mu_s = wd->dMuS;
		if (wd->dMuR == -1.) /* mu_r */
			mu_r = smf->FO.DP.dMuR;
		else
			mu_r = wd->dMuR;
		if (wd->dMuT == -1.) /* mu_t */
			mu_t = smf->FO.DP.dMuT;
		else
			mu_t = wd->dMuT;
		/* dTangentialSpringDrag = 0; *//* set to zero above (disabled) */

#ifdef OVERLAP_OUTPUT /* this will only work if nParticles is small, otherwise it should seg fault b/c it can't allocate memory */
		static double x_maxWall[nParticles][MAX_NUM_OVERLAPS_PER_PARTICLE_FOR_WALLS];
		if (liStep == 1)
			x_maxWall[p->iOrder][j] = 0;
#endif /* OVERLAP_OUTPUT */

		iOverlap = -1; /* for safety */
		F_outershell = 0.;

		vectorCopy(wd->vOrigin,O);
		vectorCopy(wd->vOrient,n);
		bApplyForce = bFoundNbr = 0;

		/* determine bApplyForce */
		if (wd->iType == WallPlane || wd->iType == WallDisk || wd->iType == WallRectangle ||
		    wd->iType == WallTriangle || wd->iType == WallCylinderFinite) {

			/*
			** find distance from particle center to plane.
			**
			** strategy:
			** find eqn of plane in form: (A*x + B*y + C*z = D).
			** eqn of line through particle center and closest point to plane is r + d*n,
			** where r is the particle center, n is the normal, and d*n is the distance.
			**
			** Combine and solve for d.
			*/

			d = vectorDot(p->r,n) - vectorDot(O,n); /* particle center lies a distance d off plane */ /* edit here to save time by subtracting vectors first then perform single dot product */
			if (fabs(d) >= r1 && wd->iType != WallCylinderFinite)
				bApplyForce = 0;
			else {
				vectorScale(n,d,vDum);
				vectorSub(p->r,vDum,q); /* q is now projection of particle center onto plane */
				switch (wd->iType) {
				case WallCylinderFinite: /* move this entire case outside this switch?? */

					if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"checking for overlap with finite cylinder: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

					/*
					** note: For particle radius larger than cylinder radius that lies inside cylinder,
					** only the force from the point on the cylinder closest to center of particle
					** will be felt. If needed, a correction might be added by scaling down this force
					** to account for the counterbalancing net force from the opposite direction. For
					** particles centered inside the cylinder and directly on the cylinder axis, no
					** no force is felt from the sides of the cylinder. On the axis inside a tapered
					** cylinder, a net force is applied "down" the axis toward the wide end via the
					** creation of a phantom point (described below). On the axis inside a uniform
					** no force is applied whatsoever.
					*/

					dRadius = wd->dRadius;
					dLength = wd->dLength;
					dTaper = wd->dTaper;

					dRadNarrow = dRadius*(1. - dTaper); /* cylinder's narrow-end ring (for taper) */
					vectorSub(q,O,vDum); /* points from cylinder axis to particle center parallel to orthogonal plane */
					a2 = vectorMagSq(vDum);
					a1 = dRadius + r1;
					a3 = max(dRadNarrow - r1,0.0);

					/*
					** start with a quick overinclusive proximity check:
					** does any part of the particle lie between
					** cylinder of radius dRadius*[1-dTaper] and
					** cylinder of radius dRadius (both of length dLength)?
					** (if not --> !bApplyForce)
					*/

					if (fabs(d + d) <= dLength + r1 + r1 && a2 <= a1*a1 && a2 >= a3*a3) {
						if (a2 != 0.0) {
							vectorScale(vDum,1./sqrt(a2),t); /* unit vector from cyl axis to p perp to cyl axis */
							vectorScale(t,dRadNarrow,vDum);
							vectorScale(n,0.5*dLength,vDum3);
							vectorAdd(vDum,vDum3,vDum); /* vector from O to point on narrow rim closest to p */
							vectorScale(t,dRadius,vDum2);
							vectorSub(vDum2,vDum3,vDum2); /* vector from O to point on wide rim closest to p */
							vectorSub(p->r,O,vDum3); /* vector pointing from O to p */
							vectorGetClosestPointOnSegment(vDum,vDum2,vDum3,vDum);
							vectorAdd(O,vDum,q); /* point on cylinder closest to p */
							vectorSub(p->r,q,vDum);
							bApplyForce = demCheckOverlapPoint(vDum,r1sq);
							}
						else { /* special case: p lies on cylinder axis */

							/*
							** (for the time being at least) some cleanliness is sacrificed for speed,
							** since the following is mostly 2D:
							**
							**
							** If there is an overlap in this case, the overlap occurs over a ring that
							** is symmetric around the cylinder axis, and therefore the overlap is
							** radially symmetric. The net force should point along the axis, so the
							** strategy used here is to create a "phantom" overlap point on the axis that
							** penetrates the particle by the same amount as it is penetrated by the ring.
							*/

							/* a vector pointing from a point on the narrow rim to p (cyl coords): */
							vectorSet(vDum2,0.,-dRadNarrow,d - 0.5*dLength);

							/* a vector pointing from a point on the wide rim to p (cyl coords): */
							vectorSet(vDum,0.,-dRadius,d + 0.5*dLength);
							
							if (d + d > dLength) {
								if (r1 >= dRadNarrow) { /* skips the next calculation if not needed */
									b = vDum2[1]*vDum2[1] + vDum2[2]*vDum2[2]; /* vectorMagSq(vDum2) */
									if ((bApplyForce = (b <= r1sq))) { /*DEBUG: modularize this and next few lines...*/
										vectorScale(n,d - sqrt(b),vDum);
										vectorAdd(O,vDum,q);
										}
									}
								}

							/*
							** only *tapered* cylinders will push out a particle whose center is
							** 'inside' the cylinder and centered directly on the axis, so we'll
							** ignore particles inside a non-tapered cylinder. Strictly speaking,
							** tapered and non-tapered cylinders should provide frictional
							** stability to particles with radii larger than the cylinders
							** that lie inside the cylinder and directly on the axis. If this
							** proves to be an issue, it can be dealt with as a special case.
							*/
							else if (dTaper || (d + d < -dLength)) {
								vectorZero(vDum3);
								vectorGetClosestPointOnSegment(vDum,vDum2,vDum3,vDum);
								/*
								** vDum is in fact now a *vector* that points from the closest
								** point on the cylinder to the particle's center, in cylinder
								** coordinates.
								*/

								b = vectorMagSq(vDum);
								if ((bApplyForce = (b <= r1sq))) {
									vectorScale(n,d + sqrt(b),vDum);
									vectorAdd(O,vDum,q);
									}
								}
							}
						}
					break;

				case WallPlane:

					if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"overlap with infinite plane: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

					bApplyForce = 1;
					break;

				case WallDisk:

					if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"checking for overlap with disk: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

					/*
					** find distance to disk.
					**
					** strategy:
					** compare | q - wall_origin | to disk radius, if less q is on disk.
					** if more, find the point on rim closest to q, then
					** compare | p->r - this point | to particle radius, if less particle is touching rim.
					**
					** to find such a point on the rim closest to q, add to origin:
					** (disk radius)*(normalized vector pointing from origin to q).
					*/

					vectorSub(q,O,vDum); /* radial component of vector from origin to particle */
					b = vectorMagSq(vDum);
					a1 = wd->dRadius*wd->dRadius;
					a2 = wd->dHoleRadius*wd->dHoleRadius;
					bOutcome = (b >= a2) + (b >= a2) + (b <= a1);

					/* hole radius bigger than disk radius */
					if (!bOutcome) {
						mdlassert(smf->pkd->mdl,0);
						}

					/* contact is flush on plane of disk */
					else if (bOutcome == 3) {
						bApplyForce = 1;
						}

					/* check for contact with outer rim of disk */
					else if (bOutcome == 2) {
						vectorNorm(vDum); /* could save time by scaling once, not thrice */
						vectorScale(vDum,wd->dRadius,vDum);
						vectorAdd(O,vDum,q); /* q is now point on disk rim closest to particle */
						vectorSub(p->r,q,vDum);
						d = vectorMagSq(vDum);
						if (d <= r1sq) {
							bApplyForce = 1;
							}
						}

					/* check for contact with inner rim of disk */
					else if (bOutcome == 1) {
						if (b != 0.) {
							vectorNorm(vDum); /* could save time by scaling once, not thrice */
							vectorScale(vDum,wd->dHoleRadius,vDum);
							vectorAdd(O,vDum,q); /* q is now point on disk rim closest to particle */
							vectorSub(p->r,q,vDum);
							d = vectorMagSq(vDum);
							if (d <= r1sq) {
								bApplyForce = 1;
								}
							}
						else { /* particle center on normal axis of disk with hole */
							if (r1 >= wd->dHoleRadius) { /* skips the next calculation if not needed */
								b = wd->dHoleRadius*wd->dHoleRadius + d*d; /* d is still distance off plane perp to plane */
								if ((bApplyForce = (b <= r1sq))) {
									vectorScale(n,d - sign(d)*sqrt(b),vDum);
									vectorAdd(O,vDum,q);
									}
								}
							}
						}
					break;

				case WallRectangle:

					if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"checking for overlap with rectangle: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

					/*
					** find distance to rectangle.
					**
					** strategy:
					** first see if q falls inside rectangle by solving for a & b.
					** if both have values between 0 and 1 (inclusive), q is on rectangle.
					** otherwise, set to closest point on rectangle, then check proximity.
					**
					** on which edge or corner this point lies depends upon the values of a & b.
					*/

					vectorCopy(wd->vVertex1,v1);
					vectorCopy(wd->vVertex2,v2);
					vectorSub(q,O,vDum);

					for (i=0;i<3;i++)
						vectorSet(A[i],v1[i],v2[i],n[i]);

					matrixInverse(A,A);
					a = vectorDot(A[0],vDum);
					b = vectorDot(A[1],vDum); /* note: vectorDot(A[2],vDum) should be zero */

					if (a >= 0. && a <= 1. && b >= 0. && b <= 1.)
						bApplyForce = 1;
					else { /* eight cases: four edges, four corners */

						/* segment joining points O and (O + v2) */
						if (a < 0. && b >= 0. && b <= 1.) {
							vectorScale(v2,b,vDum);
							vectorAdd(O,vDum,q);
							}

						/* segment joining points (O + v1) and (O + v1 + v2) */
						else if (a > 1. && b >= 0. && b <= 1.) {
							vectorScale(v2,b,vDum);
							vectorAdd(O,vDum,vDum);
							vectorAdd(v1,vDum,q);
							}

						/* segment joining points O and (O + v1) */
						else if (b < 0. && a >= 0. && a <= 1.) {
							vectorScale(v1,a,vDum);
							vectorAdd(O,vDum,q);
							}

						/* segment joining points (O + v2) and (O + v1 + v2) */
						else if (b > 1. && a >= 0. && a <= 1.) {
							vectorScale(v1,a,vDum);
							vectorAdd(O,vDum,vDum);
							vectorAdd(v2,vDum,q);
							}

						/* corner at point of origin */
						else if (a < 0. && b < 0.)
							vectorCopy(O,q);

						/* corner at point (O + v1) */
						else if (a > 1. && b < 0.)
							vectorAdd(O,v1,q);

						/* corner at point (O + v2) */
						else if (a < 0. && b > 1.) {
							vectorAdd(O,v2,q);
							/* printf("a=%e b=%e\n",a,b); */
							}

						/* corner at point (O + v1 + v2) */
						else if (a > 1. && b > 1.) {
							vectorAdd(O,v1,vDum);
							vectorAdd(vDum,v2,q);
							}

						else
							mdlassert(smf->pkd->mdl,0); /* keep things honest */

						vectorSub(p->r,q,vDum);
						bApplyForce = demCheckOverlapPoint(vDum,r1sq);
						}
					break;

				case WallTriangle:

					if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"checking for overlap with triangle: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

					/*
					** find distance to triangle.
					**
					** strategy:
					** first see if q falls inside triangle by solving for a & b.
					** if both are non-negative and they sum to a value no greater than unity, q is on triangle.
					** otherwise, set q to closest point on triangle, then check proximity.
					**
					** on which edge or corner this point lies depends upon the values of a & b.
					*/

					vectorCopy(wd->vVertex1,v1);
					vectorCopy(wd->vVertex2,v2);
					vectorSub(q,O,vDum);

					for (i=0;i<3;i++)
						vectorSet(A[i],v1[i],v2[i],n[i]);

					matrixInverse(A,A);
					a = vectorDot(A[0],vDum);
					b = vectorDot(A[1],vDum); /* note: vectorDot(A[2],vDum) should be zero */

					if (a >= 0. && b >= 0. && (a + b) <= 1.)
						bApplyForce = 1;
					else { /* six cases: three edges, three corners (but we combine two corners and an edge) */

						/* segment joining points O and (O + v2) */
						if (a < 0. && b >= 0. && b <= 1.) {
							vectorScale(v2,b,vDum);
							vectorAdd(O,vDum,q);
							}

						/* segment joining points O and (O + v1) */
						else if (b < 0. && a >= 0. && a <= 1.) {
							vectorScale(v1,a,vDum);
							vectorAdd(O,vDum,q);
							}

						/* corner at point of origin */
						else if (a < 0. && b < 0.)
							vectorCopy(O,q);

						/* segment joining points (O + v1) and (O + v2), including points v1 and v2 */
						/* DEBUG: separate these three cases for increased speed */
						else {
							vectorSub(q,O,vDum);
							vectorGetClosestPointOnSegment(v1,v2,vDum,vDum);
							vectorAdd(O,vDum,q);
							}

						vectorSub(p->r,q,vDum);
						bApplyForce = demCheckOverlapPoint(vDum,r1sq);
						}
					break;

				default:
					mdlassert(smf->pkd->mdl,0);
					}
				}
			}

		else if (wd->iType == WallCylinderInfinite) {

			if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"checking for overlap with infinite cylinder: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

			vectorSub(O,p->r,vDum);
			vectorCross(n,vDum,vDum2);
			d = vectorMagSq(vDum2); /* sqare of distance from particle center to cylinder axis */
			a1 = wd->dRadius + r1;
			a2 = wd->dRadius - r1;
			a3 = max(a2,0.0);
			if (d != 0.0 && d <= a1*a1 && d >= a3*a3) {
				a = -vectorDot(n,vDum); /* scalar projection of segment (p->r - O) onto cylinder axis */
				vectorScale(n,a,vDum); /* vector pointing from O to point on cylinder axis closest to particle center */
				vectorSub(p->r,vDum,vDum2);
				vectorSub(vDum2,O,vDum2); /* vector pointing from cylinder axis to particle center */
				d = sqrt(d); /* equivalent to magnitude of current vDum2 vector */
				vectorScale(vDum2,wd->dRadius/d,vDum2);
				vectorAdd(O,vDum,vDum);
				vectorAdd(vDum,vDum2,q); /* point on cylinder closest to center of particle */
				bApplyForce = 1;
				}
			/*
			** note: For particle radius larger than cylinder radius
			** that lies inside cylinder, only the force from the
			** point on the cylinder closest to center of particle
			** will be felt. If this case for some reason has a need
			** to be explored, consider scaling down this force to
			** account for counterbalancing net force in the opposite
			** direction. Also, relatedly, for such a particle
			** centered directly on the cylinder axis, rather than the
			** particle being "pinned" to its spot inside the
			** cylinder, no force is felt. Both of these conditions
			** also apply to finite cylinders of uniform width. In the
			** case of the tapered finite cylinder, similar scenarios
			** are treated with more care (discussed in that section
			** of the code).
			**
			** again, if such a case proves salient somehow, revamp
			** accordingly.
			*/
			}

		else if (wd->iType == WallShell) {

			if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"checking for overlap with shell: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,w->iWallID);

			/*
			** note: the closer the particle's cross-sectional radius
			** (along the plane of contact perpendicular to the
			** shell's axis of symmetry) is to the shell's
			** cross-sectional radius on this same plane, the less
			** accurate the treatment stricly is. For example,
			** consider the difference between an impact on the inside
			** vs. an impact on the outside of the shell - a
			** penetration of 'x' from the inside implies a greater
			** degree of overlap than a penetration of 'x' on from the
			** outside, but the treatment is ** identical (similar in
			** the case of a cylinder).
			*/

			dOpenAngle = wd->dOpenAngle*M_PI/180.; /* use radians */
			dRadius = wd->dRadius;
			vectorSub(p->r,O,vDum);
			a = vectorMagSq(vDum);
			a1 = dRadius + r1;
			a3 = max(dRadius - r1,0.0);
			if (a != 0.0 && a >= a3*a3 && a <= a1*a1) {
				a = sqrt(a);
				d = vectorDot(n,vDum);
				dAngle = acos(d/a);
				if (dAngle >= dOpenAngle) {
					vectorScale(vDum,dRadius/a,vDum2);
					vectorAdd(O,vDum2,q);
					bApplyForce = 1;
					}
				else {
					/* find point on rim closest to p */
					vectorScale(n,d,vDum2);
					vectorSub(vDum,vDum2,vDum2); /* (p - O) projected onto plane perp to n containing (0,0) */
					b = vectorMagSq(vDum2); /* |(p - O)|sin(dAngle) squared */
					if (b == 0.) { /* case where particle center lies directly on normal axis */
						b2 = dRadius*sin(dOpenAngle);
						if (b2 <= r1) {
							b1 = dRadius*cos(dOpenAngle);
							a2 = b2*b2 + (d - b1)*(d - b1); /* dist from center of particle to rim */
							if ((bApplyForce = (a2 <= r1sq))) {
								if (d > b1)
									vectorScale(n,d - sqrt(a2),vDum);
								else if (d < b1)
									vectorScale(n,d + sqrt(a2),vDum);
								else
									mdlassert(smf->pkd->mdl,0);
								vectorAdd(O,vDum,q); /* q is the "phantom point" (see finite cylinder for description) */
								}
							}
						}
					else {
						b1 = cos(dOpenAngle);
						vectorScale(vDum2,dRadius*sqrt((1. - b1*b1)/b),vDum2); /* norm(vDum2)*dRadius*sin(dOpenAngle) */
						vectorScale(n,dRadius*b1,vDum3);
						
						/*
						** vDum2 is now projection of desired point on rim onto plane perp to n containing (0,0)
						** vDum3 is now projection of desired point on rim onto n
						*/

						vectorAdd(vDum3,vDum2,vDum3);
						vectorSub(vDum,vDum3,vDum2);
						if ((bApplyForce = demCheckOverlapPoint(vDum2,r1sq)))
							vectorAdd(O,vDum3,q);
						}
					}
				}
			}

		else
			mdlassert(smf->pkd->mdl,0); /* if this is tripped, ensure wall type is supported */		

		if (dEpsN < 0.0) { /* death wall */
			if (bApplyForce) {

				/* clear particle-particle DEM elements */
				for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE;i++) {
					pe = &p->overlaps[i];
					pe->iOrder = -1; /* unused neighbor slot */
					vectorZero(pe->vShear);
					vectorZero(pe->vnOld);
					pe->liOverlapCounter = 0;
					}

				/* clear particle-wall DEM elements */
				for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE_FOR_WALLS;i++) {
					we = &p->walloverlaps[i]; /* 'we' pointer reset here...particle will be killed off anyway */
					we->iOrder = -1; /* unused neighbor slot */
					vectorZero(we->vShear);
					vectorZero(we->vnOld);
					we->liOverlapCounter = 0;
					}

				/* clear neighbors' contact lists of deceased particle -- alternatively, this could be done in a new function call in master just before msrAddDelParticle() */
				DEM_ELEMENT *pne;
				int k;
				/* printf("here %i \n",p->iOrder); *//*DEBUG*/
				for (k=0;k<nSmooth;k++) {
					pn = nnList[k].pPart;
					if (pn->iOrder < p->iOrder)
						/* printf("now here %i %i\n",p->iOrder,pn->iOrder); *//*DEBUG*/
						for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE;i++) {
							pne = &pn->overlaps[i];
							/* printf("and here %i %i %i\n",p->iOrder,pne->iOrder,pn->iOrder); *//*DEBUG*/
							if (pne->iOrder == p->iOrder) {
#ifdef OVERLAP_OUTPUT
								fprintf(overlapOUT,"%g %d %d %li %e death\n",smf->dTime,pn->iOrder,pne->iOrder,pne->liOverlapCounter,x_maxWall[pn->iOrder][i]);
								x_maxWall[pn->iOrder][i] = 0.;
#endif /* OVERLAP_OUTPUT */
								/* printf("%i %i %i\n",p->iOrder,pne->iOrder,pn->iOrder); */
								pne->iOrder = -1;
								vectorZero(pne->vShear);
								vectorZero(pne->vnOld);
								pne->liOverlapCounter = 0;
								if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"iOrder %i(%i) cleared from overlap list of neighbor %i\n",p->iOrder,smf->pkd->idSelf,pn->iOrder);
								break;
								}
							}
					}
				pkdDeleteParticle(smf->pkd,p);
				}
			continue;
			}

		/* determine bFoundNbr */

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"bApplyForce = %i, determining bFoundNbr: iOrder = %i(%i), wallID = %i\n",bApplyForce,p->iOrder,smf->pkd->idSelf,w->iWallID);

		for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE_FOR_WALLS;i++) {
			we = &p->walloverlaps[i];
			if (we->iOrder == w->iWallID) {
				mdlassert(smf->pkd->mdl,!bFoundNbr); /* ensure no duplicate overlaps */
				bFoundNbr = 1;
				iOverlap = i;
				}
			}

		/* two binaries, four cases: */
		if (bFoundNbr && bApplyForce) {
			we = &p->walloverlaps[iOverlap];
#ifndef DEM_TWOLAYERS
			++we->liOverlapCounter;
#endif
			}

		else if (bFoundNbr && !bApplyForce) {
			we = &p->walloverlaps[iOverlap];
#ifdef OVERLAP_OUTPUT
			fprintf(overlapOUT,"%g W_%d %d %li %e\n",smf->dTime,we->iOrder,p->iOrder,we->liOverlapCounter,x_maxWall[p->iOrder][j]);
			x_maxWall[p->iOrder][j] = 0.;
#endif /* OVERLAP_OUTPUT */
			we->iOrder = -1;
			vectorZero(we->vShear);
			vectorZero(we->vnOld);
			we->liOverlapCounter = 0; /* could insert warning here before reset if liOverlapCounter is too low */
			continue;
			}

		else if (!bFoundNbr && bApplyForce) {
			for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE_FOR_WALLS;i++) {
				we = &p->walloverlaps[i];
				if (we->iOrder == -1) {
					iOverlap = i;
					we->iOrder = w->iWallID;
					vectorZero(we->vShear);
					vectorZero(we->vnOld);
#ifndef DEM_TWOLAYERS
					we->liOverlapCounter = 1;
#endif
					break;
					}
				}
			mdlassert(smf->pkd->mdl,i < MAX_NUM_OVERLAPS_PER_PARTICLE_FOR_WALLS); /* ensure free spot was indeed found and used */
			}

		else if (!bFoundNbr && !bApplyForce)
			continue;

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"bApplyForce = %i, bFoundNbr = %i: iOrder = %i(%i), wallID = %i\n",bApplyForce,bFoundNbr,p->iOrder,smf->pkd->idSelf,we->iOrder);

		mdlassert(smf->pkd->mdl,iOverlap >= 0 && we->iOrder == w->iWallID && iOverlap < MAX_NUM_OVERLAPS_PER_PARTICLE_FOR_WALLS);

		we = &p->walloverlaps[iOverlap]; /* we now points to the overlap of this particle and its neighbor */

		m1 = p->fMass;
#ifdef AGGS
		if (IS_AGG(p))
			m1 = p->fMassAgg;
#endif /* AGGS */
		dReducedMass = m1;
		dSqrtReducedMass = sqrt(dReducedMass);
		vectorSub(q,p->r,n);
		d = vectorMag(n); /* scalar distance to wall */
		x = r1 - d; /* probably want to be checking x/d for avg and max, warning if max is large... */
		i1 = 0.4*m1*r1*r1;

#ifdef DEM_TWOLAYERS

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"iOrder = %i(%i), wallID = %i, vShear before boundary cross check = %.16e\n",p->iOrder,smf->pkd->idSelf,we->iOrder,vectorMag(we->vShear));

		dInBnd = r1*dInBndFrac;
		if (x > dInBnd) {
			kn = kn_inner;
			kt = kt_inner;
			x_inner = x - dInBnd;
			mdlassert(smf->pkd->mdl,x_inner >= 0.0);
			F_outershell = dInBnd*kn_outer;
			if (we->liOverlapCounter <= 0)
				--we->liOverlapCounter;
			else { /* scale static spring if boundary layer was just crossed (conserve energy in tang spring: 1/2 kt*(vShear)^2 */
#ifdef OVERLAP_OUTPUT
				fprintf(overlapOUT,"inner boundary crossed - %g W_%d %d %li %e\n",smf->dTime,we->iOrder,p->iOrder,we->liOverlapCounter,x_maxWall[p->iOrder][j]);
#endif
				vectorScale(we->vShear,sqrt(kt_outer/kt_inner),we->vShear); /* vnOld remains the same */
				we->liOverlapCounter = -1;
				}
			}
		else {
			kn = kn_outer;
			kt = kt_outer;
			x_inner = -1.;
			F_outershell = 0.;
			if (we->liOverlapCounter >= 0)
				++we->liOverlapCounter;
			else { /* scale static spring... */
#ifdef OVERLAP_OUTPUT
				fprintf(overlapOUT,"inner boundary crossed - %g W_%d %d %li %e\n",smf->dTime,we->iOrder,p->iOrder,we->liOverlapCounter,x_maxWall[p->iOrder][j]);
#endif
				vectorScale(we->vShear,sqrt(kt_inner/kt_outer),we->vShear);
				we->liOverlapCounter = 1;
				}
			}
		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"iOrder = %i(%i), wallID = %i, vShear after boundary cross check = %.16e, overlap = %.16e, inner boundary = %.16e, overlap with inner layer = %.16e, kt_inner = %.16e, kt_outer = %.16e\n",p->iOrder,smf->pkd->idSelf,we->iOrder,vectorMag(we->vShear),x,dInBnd,x_inner,kt_inner,kt_outer);

#endif /* DEM_TWOLAYERS */
		
#ifdef OVERLAP_OUTPUT
		if (x > x_maxWall[p->iOrder][j])
			x_maxWall[p->iOrder][j] = x;
#endif /* OVERLAP_OUTPUT */

		int iWarningType = DEM_NOERR;
		if (!PARTICLE_STUCK(p)) { /* (ignore stuck particles, any wall) */ /* entire walls portion of DoDEM() should be skipped anyway -srs */
			if ((x > smf->FO.DP.dErrorFrac*r1))
				iWarningType = DEM_ERROR;
			else if ((x > smf->FO.DP.dMajorFrac*r1))
				iWarningType = DEM_MAJOR;
			else if ((x > smf->FO.DP.dMinorFrac*r1))
				iWarningType = DEM_MINOR;
			}
		if (iWarningType != DEM_NOERR) {
#if (INTERNAL_WARNINGS != 0)
			static int nWarnWall = 1;
			if (nWarnWall == 1 || nWarnWall%INTERNAL_WARNINGS == 0 || iWarningType != DEM_MINOR)
				(void) fprintf(stderr,"DEM WALL WARNING #%i (pid=%i) [T=%g]: %s: %i onto Wall %i = %f%%\n",
							   nWarnWall,smf->pkd->idSelf,smf->dTime,iWarningType == DEM_MINOR ? "minor overlap" :
							   iWarningType == DEM_MAJOR ? "major overlap" : "overlap error",p->iOrder,w->iWallID,
							   100.*x/r1);
			++nWarnWall;
#endif /* INTERNAL_WARNINGS */
			mdlassert(smf->pkd->mdl,iWarningType != DEM_ERROR);
			}
		
		static int bCnCtPreFacCalculatedWalls[MAX_NUM_WALLS]; /* since dEpsN and dEpsT are identical for all particles in sim (but not for each wall) */

		static int bCnCtPreFacCalculatedWallsInitialized = 0;
		if (!bCnCtPreFacCalculatedWallsInitialized) {
			for (i=0;i<MAX_NUM_WALLS;i++)
				bCnCtPreFacCalculatedWalls[i] = 0;
			bCnCtPreFacCalculatedWallsInitialized = 1;
			}

		if (!bCnCtPreFacCalculatedWalls[w->iWallID]) {
			/* damping term: normal */
			dLnEpsN = log(dEpsN);
			dLnEpsNsq = dLnEpsN*dLnEpsN;
			a = pi_sq + dLnEpsNsq;
			CnPreFacWalls[w->iWallID] = -sign(dLnEpsN)*sqrt(dLnEpsNsq*kn/a);
			CnPreFacWalls[w->iWallID] += CnPreFacWalls[w->iWallID];
#ifdef DEM_TWOLAYERS
			CnInnerPreFacWalls[w->iWallID] = -sign(dLnEpsN)*sqrt(dLnEpsNsq*kn_inner/a);
			CnInnerPreFacWalls[w->iWallID] += CnInnerPreFacWalls[w->iWallID];
			CnOuterPreFacWalls[w->iWallID] = -sign(dLnEpsN)*sqrt(dLnEpsNsq*kn_outer/a);
			CnOuterPreFacWalls[w->iWallID] += CnOuterPreFacWalls[w->iWallID];
#endif

			/* damping term: tangential */
			dLnEpsT = log(dEpsT);
			dLnEpsTsq = dLnEpsT*dLnEpsT;
			a = pi_sq + dLnEpsTsq;
			CtPreFacWalls[w->iWallID] = -sign(dLnEpsT)*sqrt(dLnEpsTsq*kt/a);
			CtPreFacWalls[w->iWallID] += CtPreFacWalls[w->iWallID];
#ifdef DEM_TWOLAYERS
			CtInnerPreFacWalls[w->iWallID] = -sign(dLnEpsT)*sqrt(dLnEpsTsq*kt_inner/a);
			CtInnerPreFacWalls[w->iWallID] += CtInnerPreFacWalls[w->iWallID];
			CtOuterPreFacWalls[w->iWallID] = -sign(dLnEpsT)*sqrt(dLnEpsTsq*kt_outer/a);
			CtOuterPreFacWalls[w->iWallID] += CtOuterPreFacWalls[w->iWallID];
#endif
			(void) printf("CnInnerPreFacWalls and CtInnerPreFacWalls calculated for wall %d on pid %i\n",w->iWallID,smf->pkd->idSelf);
			bCnCtPreFacCalculatedWalls[w->iWallID] = 1;
			}

		/* components of a unit normal vector from particle center to wall */
		mdlassert(smf->pkd->mdl,d != 0.0);
		vectorScale(n,1./d,n);

		/* velocity of particle at contact point w.r.t. its COM */
		vectorCross(p->wPred,n,vDum);
		vectorScale(vDum,d,s1);

		/* velocity of wall at contact point */
		if (wd->dAngSpeed != 0.) { /* save time if wall is not spinning */
			vectorScale(wd->vOrient,wd->dAngSpeed,vVinyl); /* spin of wall (vector) */
			vectorSub(q,O,vDum2); /* lever-arm (vector) */
			vectorCross(vVinyl,vDum2,v); /*DEBUG: not fully tested! at this point, v should be velocity at CP due to rotation of wall*/
			vectorAdd(v,w->vTotVel,v); /*DEBUG: and at this point, v should be total velocity of wall at the contact point*/
			}
		else {
			vectorCopy(w->vTotVel,v);
			vectorZero(vVinyl); /* used later when computing torques */
			}

		/*DEBUG: test*/
		if (dEpsN == 0.0) { /* sticky wall */
#ifdef AGGS
			mdlassert(smf->pkd->mdl,!IS_AGG(p)); /* way too complicated to let aggs stick to walls... *//*DEBUG if we ever allow particles to merge to form aggs with DEM, be aware of the possibility of one of the particles already being stuck to a wall...*/
#endif /* AGGS */
			if (p->iColor >= 0) p->iColor = -1 - w->iWallID;
			vectorZero(p->a); /* not essential: stuck particles are not kicked */
			vectorCopy(w->vTotVel,p->v); /* transfer wall motion to particle */
			vectorZero(p->w);
			if (COLLIDER_STUCK_ON_ROTATING_WALL(p,WP)) {
				/* transfer wall spin to particle */
				mdlassert(smf->pkd->mdl,wd->iType != WallTriangle && wd->iType != WallRectangle); /* not supported at the moment */
				vectorScale(wd->vOrient,wd->dAngSpeed,p->w);
				}
			return;
			}

		Un = Ut = Rt = 0.;
		if (mu_r != 0.) {
			for (i=0;i<3;i++) {
				v[i] -= p->vPred[i]; /* particle velocity */ /*DEBUG! make sure no sliding patch with walls*/
				s[i] = -s1[i]; /* particle spin */
				r[i] = s1[i]; /* rolling */ /*DEBUG: how to treat wall motion/rotation affect on spin? (no effect for now)*/
				u[i] = v[i] + s[i];
				Un += u[i]*n[i];
				}

			for (i=0;i<3;i++) {
				un[i] = Un*n[i];
				ut[i] = u[i] - un[i];
				Ut += ut[i]*ut[i];
				Rt += r[i]*r[i];
				}

			Ut = sqrt(Ut);
			Rt = sqrt(Rt);
			}
		else {
			for (i=0;i<3;i++) {
				v[i] -= p->vPred[i]; /* particle velocity */ /*DEBUG! make sure no sliding patch with walls*/
				s[i] = -s1[i]; /* particle spin */
				u[i] = v[i] + s[i];
				Un += u[i]*n[i];
				}

			for (i=0;i<3;i++) {
				un[i] = Un*n[i];
				ut[i] = u[i] - un[i];
				Ut += ut[i]*ut[i];
				}

			Ut = sqrt(Ut);
			}
		/* unit tangential velocity vector */
		if (Ut != 0.0)
			vectorScale(ut,1./Ut,t);
		else
			vectorZero(t); /* avoid dividing by zero */
		
		/* unit rolling vector */
		if (Rt != 0.0) /* Rt always zero if mu_r is zero (above), so !Rt condition is better here */
			vectorScale(r,1./Rt,rt); /* rt[i] = unit vector of spinning component at contact point */
		else
			vectorZero(rt); /* rt[i] = unit vector of spinning component at contact point */

		/* damping terms */
#ifndef DEM_TWOLAYERS
		Cn = CnPreFacWalls[w->iWallID]*dSqrtReducedMass;
		Ct = CtPreFacWalls[w->iWallID]*dSqrtReducedMass; /* ...relating dEpsN,dEpsT to Cn,Ct comes from Cleary etal. '98 */
#else  /* if an inner boundary is defined where stiffness changes */
		if (x > dInBnd) {
			Cn = CnInnerPreFacWalls[w->iWallID]*dSqrtReducedMass;
		   	Ct = CtInnerPreFacWalls[w->iWallID]*dSqrtReducedMass;
			}
		else {
			Cn = CnOuterPreFacWalls[w->iWallID]*dSqrtReducedMass;
		   	Ct = CtOuterPreFacWalls[w->iWallID]*dSqrtReducedMass;
			}
#endif /* DEM_TWOLAYERS */

		a1 = 1./m1;
		b1 = 1./i1;

		/* Tangential displacement vector */

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"Starting calculation on tangential displacement vector: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,we->iOrder);

		if (vectorMagSq(we->vnOld) != 0.0) {
#ifndef DEM_TWOLAYERS /* if boundary is crossed, vnOld will be defined and |liOverlapCounter| == 1 */
			mdlassert(smf->pkd->mdl,we->liOverlapCounter > 1); /* should not be first step in overlap */
#endif

			/* see comments in particle-particle section above */

			/*
			** If vnOld is not stored in the DEM element struct, we need to compute it somehow.
			** This is straightforward only in the case where vnOld can be easily predicted, as
			** in the case where a particle will interact only with the face of a wall, where
			** n is constant in time (n = vnOld). Otherwise *very* complicated!
			*/

			/*
			** We first consider rotation around the normal - for this,
			** we simply rotate the tangential spring around the average
			** of the previous normal and the current normal.  So we use
			** the normal and the spins of 1/2 step ago (midpoint).
			*/

			vectorAdd(p->w,vVinyl,vDum);
			vectorAdd(we->vnOld,n,vDum2);
			vectorNorm(vDum2);

			/* could consider checking that this is nonzero before expensive next op, but only in special cases will it be nonzero... */
			vectorRotate(we->vShear,vDum2,0.5*dDelta*vectorDot(vDum,vDum2));

			/*
			** Next, we change the orientation of the displacement vector
			** in the same way that the orientation of the normal has
			** changed over the previous step, and assume that the normal
			** did not change by more than 90 degrees
			*/

			/*
			vectorScale(n,vectorDot(n,we->vShear),vDum);
			vectorSub(we->vShear,vDum,vDum);
			if ((a = vectorMagSq(vDum)) != 0.0)
				vectorScale(vDum,sqrt(vectorMagSq(we->vShear)/a),we->vShear);
			*/

			vectorCross(n,we->vnOld,vDum); // axis of rotation (not normalized)
			if ((a = vectorMagSq(vDum)) != 0.0) {
				a = sqrt(a);
				vectorScale(vDum,1./a,vDum);
				vectorRotate2(we->vShear,vDum,a,vectorDot(n,we->vnOld)); // converting to an angle and using vectorRotate() failed when recomputing the sin and cos
				}
			}

		/* set vnOld to current n for use in next step in the case that the overlap persists to the next step */
		vectorCopy(n,we->vnOld);

		N = T = 0.; /* normal force */

#ifdef DEM_TWOLAYERS
		if (x_inner >= 0.0)
			x = x_inner; /* if an inner boundary is defined where stiffness changes and is penetrated */
#endif

		/* forces */

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"Starting calculation on static friction effects: iOrder = %i(%i), wallID = %i\n",p->iOrder,smf->pkd->idSelf,we->iOrder);

		for (i=0;i<3;i++) {
			we->vShear[i] += ut[i]*dDelta; /* this step's contribution to the tangential spring */
			Fn[i] = -(kn*x + F_outershell)*n[i] + Cn*un[i]; /* check to ensure that all other forces are computed first (e.g. gravity) */
			Ft[i] = kt*we->vShear[i] + Ct*ut[i]; /*      ""      */

			N += Fn[i]*Fn[i]; /* square of normal force */
			T += Ft[i]*Ft[i]; /* square of tangential force */

			if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"applying forces and moments: iOrder = %i(%i), wallID = %i, Ft[%i] = %.16e, vShear[%i] = %.16e, un[%i] = %.16e\n",p->iOrder,smf->pkd->idSelf,we->iOrder,i,Ft[i],i,we->vShear[i],i,un[i]);
			}
		
		F2 = N*mu_s*mu_s; /* square of max allowed static friction */
		N = sqrt(N); /* scalar magnitude of Normal force (not squared) */
#ifdef DEM_PRESSURE
		p->dPressure += N; /*DEBUG: hack to sum total pressure on particle*/
#endif

		/*DEBUG*/
		/*
		printf("DoDEM() call = %d wall = %d pe->liOverlapCounter = %li x/r = %e N = %e |S|/r = %e S/|S| dot n = %e\n",count,w->iWallID,we->liOverlapCounter,x/r1,N,vectorMag(we->vShear)/r1,vectorDot(we->vShear,n)/vectorMag(we->vShear));
		printf("S[0]/r = %e t[0] = %e  ;  F = %e  ;  Ct*Ut = %e  ;  Ft[0] = %e p->w[0] = %e\n",we->vShear[0]/r1,t[0],sqrt(F2),Ct*Ut,Ft[0],p->w[0]);
		printf("S[1]/r = %e t[1] = %e  ;  b1 = %e  ;  Ut = %e  ;  Ft[1] = %e p->w[1] = %e\n",we->vShear[1]/r1,t[1],b1,Ut,Ft[1],p->w[1]);
		printf("S[2]/r = %e t[2] = %e  ;  l1 = %e  ;  Ct*Ut = %e  ;  Ft[2] = %e Fn[2] = %e\n",we->vShear[2]/r1,t[2],d,Ct*Ut,Ft[2],Fn[2]);
		printf("n[0] = %e n[1] = %e n[2] = %e p=%e %e %e w=%e %e %e\n",n[0],n[1],n[2],p->r[0],p->r[1],p->r[2],wd->vOrigin[0],wd->vOrigin[1],wd->vOrigin[2]);
		*/

		if (F2 < T) {
			if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"Static friction limit exceeded: iOrder = %i(%i), wallID = %i\n, tangential force = %.16e, limit = %.16e\n",p->iOrder,smf->pkd->idSelf,we->iOrder,sqrt(T),sqrt(F2));


			F = N*mu_s; /* mag of max allowed force du friction statique (not squared) */
			if (dTangentialSpringDrag != 0.0) {

				/* compute the new magnitude of vShear, but if tangential kintetic friction alone exceeds static friction, vShear will be zeroed */
				a = F - Ct*Ut;
				b = a <= 0. ? 0. : vectorMag(we->vShear);
				a = b <= 0. ? 0. : dTangentialSpringDrag*a/(kt*b);

				/* set vShear */
				vectorScale(we->vShear,a,we->vShear); /* vShear for this step */
				vectorScale(t,min(F,Ct*Ut),vDum); /* the force due to tangential kinetic friction */
				vectorScale(we->vShear,kt,vDum2);
				vectorAdd(vDum,vDum2,vDum); /* total tangential force due to both static and kinetic friction */

				mdlassert(smf->pkd->mdl,T > 0.);
				if (a != 0.0)
					vectorScale(Ft,a*b/sqrt(T),we->vShear);
				else
					vectorZero(we->vShear);					
				vectorCopy(vDum,Ft);
				}

			else {
				vectorZero(we->vShear);
				vectorScale(t,min(F,Ct*Ut),Ft);
				}
			}
 
		if (Rt != 0.)
			dRollingFriction = mu_r*N;
		else
			dRollingFriction = 0.;

		/* Below, we use "twisting friction" to damp out spin along the normal axis connecting the particles' centers */
		if (mu_t != 0.) {
		
			/* make [dTwistRate * n-hat] be the relative differential spin around normal axis: */
			vectorSub(vVinyl,p->wPred,vDum);
			dTwistRate = vectorDot(vDum,n);

			mdlassert(smf->pkd->mdl,r1sq - d*d >= 0.0);
			dContactRadius = sqrt(r1sq - d*d);
			dTwistingFriction = mu_t*N*sign(dTwistRate); /* this dotted with n-hat is the twisting friction force */
			/* printf("WALL dContactRadius=%e\nd*d=%e\nr1sq=%e\n",dContactRadius,d*d,r1sq); */ /*DEBUG:make this debug_trace*/
			}

		/* moments */
		vectorCross(Ft,n,Ftn); /* tangential DEM induced torque per unit length */
		if (Rt != 0.) {
			vectorCross(rt,n,vDum); /* unit vector giving angular direction of rolling friction torque */
			vectorScale(vDum,dRollingFriction,vRft); /* rolling friction torque per unit length */
			/* below we check to see if rolling friction impulse is greater than rolling momentum. if so, make equal */
			a = vectorMagSq(vRft);
			b = dDelta*b1*d*d;
			b *= a*b;
			//			printf("%e %e %e %e %e %e %e\n",Rt,dDelta*b1*vRft[0],sqrt(a),dDelta*b1*dDelta*b1*a,b,vectorMag(p->w)*d,vectorMag(p->wPred)*d);
			if (Rt*Rt < b) {
				vectorScale(vRft,vectorMag(p->w)*d/sqrt(b),vRft);
				//				printf("geraldine ferraro %d %e\n",p->iOrder,vRft[0]);
				}
			}
		else
			vectorZero(vRft);
		if (mu_t != 0.)
			vectorScale(n,dContactRadius*dTwistingFriction,vTfn); /* twisting friction torque */
		else
			vectorZero(vTfn);

		/* apply forces, torques */

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"applying forces and moments: iOrder = %i(%i), wallID = %i, forces on particle COM: normal = %.16e, tangential = %.16e, moments: tangential = %.16e, rolling friction = %.16e, twisting friction = %.16e\n",p->iOrder,smf->pkd->idSelf,we->iOrder,vectorMag(Fn),a1*vectorMag(Ft),(-1.)*b1*d*vectorMag(Ftn),b1*d*vectorMag(vRft),b1*d*vectorMag(vTfn));

		/*DEBUG*/
		/*
		printf("b DoDEM() call = %d wall = %d pe->liOverlapCounter = %li x/r = %e N = %e |S|/r = %e S/|S| dot n = %e\n",count,w->iWallID,we->liOverlapCounter,x/r1,N,vectorMag(we->vShear)/r1,vectorDot(we->vShear,n)/vectorMag(we->vShear));
		printf("b S[0]/r = %e t[0] = %e  ;  F = %e  ;  Ct*Ut = %e  ;  Ft[0] = %e p->w[0] = %e\n",we->vShear[0]/r1,t[0],sqrt(F2),Ct*Ut,Ft[0],p->w[0]);
		printf("b S[1]/r = %e t[1] = %e  ;  b1 = %e  ;  Ct*Ut = %e  ;  Ft[1] = %e p->w[1] = %e\n",we->vShear[1]/r1,t[1],b1,Ct*Ut,Ft[1],p->w[1]);
		printf("b S[2]/r = %e t[2] = %e  ;  l1 = %e  ;  Ct*Ut = %e  ;  Ft[2] = %e p->w[2] = %e\n",we->vShear[2]/r1,t[2],d,Ct*Ut,Ft[2],p->w[2]);
		*/

		for (i=0;i<3;i++) {
			p->dDeltaAccel[i] += (Fn[i] + /*0.5**/Ft[i])*a1;
			p->wDot[i] -= b1*(d*(/*0.5**/Ftn[i] - vRft[i]) - vTfn[i]);
			//printf("Fn[%d]=%e Ft[%d]=%e\n",i,Fn[i],i,Ft[i]);
			}
		/*DEBUG!{
			double FnMag,FtMag;
			FnMag = a1*sqrt(Fn[0]*Fn[0] + Fn[1]*Fn[1] + Fn[2]*Fn[2]);
			FtMag = a1*sqrt(Ft[0]*Ft[0] + Ft[1]*Ft[1] + Ft[2]*Ft[2]);
			if (FnMag > 2000 || FtMag > 2000)
				printf("SOUND %e %i %i %g %g\n",
					   smf->dTime,p->iOrder,-1 - w->iWallID,FnMag,FtMag);
					   }*/

		if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"particle-wall forces and moments applied: iOrder = %i(%i), wallID = %i, current tally of particle force: %.16e, moment: %.16e\n",p->iOrder,smf->pkd->idSelf,we->iOrder,vectorMag(p->dDeltaAccel),vectorMag(p->wDot));

		/*
		** Below we make a crude approximation for walls of finite mass, only in the z-direction.
		** Besides the obvious assumptions and limitations, note that the particle behaves as though
		** even these walls *all* walls have infinite mass.  Better would be to use some sort of
		** reduced mass to calculate the momentum exchange.  However, we'll assume that the particle
		** mass is small relative to the mass of the "intertial" wall assemblage.
		*/

#ifdef WALLS_REACT
		if (wd->dMass != 0.0)
			p->dZForceOnWalls -= Fn[2] + Ft[2];
#endif
		}

#endif /* WALLS */

	if (DEBUG_TRACE(p->iOrder)) fprintf(stderr,"function DoDEM() complete: iOrder = %i(%i)\n",p->iOrder,smf->pkd->idSelf);

/*#define CLEAR_BELOW_HOPPER*/ /*DEBUG: relevant for hopper only*/
#ifdef CLEAR_BELOW_HOPPER
	if (p->r[2] < -1.804836963060900027e-11/*-270*/) pkdDeleteParticle(smf->pkd,p);
#endif

	/*DEBUG!!!:Hackity-Hack*/
	/*
	double W;
	W = vectorMagSq(p->w);
	if (r1*W > 1.e-7) {
		vectorScale(p->w,(1./W),p->w);
		printf("particle spins limited to ~3mm sec DEBUG!!!\n");
		}
	*/
	/*vectorZero(p->w);*/
	}

#undef nParticles /*DEBUG!*/

#ifndef SQ
double SQ(double);
#define SQ(x) ((x)*(x))
#endif

void DEMStats(PARTICLE *p,int nSmooth,NN *nnList,SMF *smf)
{
	/*
	** Intelligent comment goes here.
	**
	** NOTE: these are only particle-particle stats; no particle-wall.
	*/

	PARTICLE *pn = NULL;
	double r,dDist,dVx,dVy,dVz,dSpeed;
	int i,iClosest=0;
	
	mdlassert(smf->pkd->mdl,nSmooth > 0);
	
	r = RADIUS(p);
	mdlassert(smf->pkd->mdl,r > 0.0); /* paranoia check */
	p->DEMStats.fDistMin = FLOAT_MAXVAL;
	p->DEMStats.fSpeedMax = 0.0;
	p->DEMStats.fOverlap = 0.0;
	p->DEMStats.fS2 = 0.0;

#ifdef WALLS
	if (PARTICLE_STUCK(p))
		return; /* don't accumulate statistics for stuck particles */  /* ...stuck particles hopefully don't get here anyway [srs] */
#endif

	for (i=0;i<nSmooth;i++) {
		pn = nnList[i].pPart;
		if (pn->iOrder == p->iOrder)
			continue;
		dDist = sqrt(nnList[i].fDist2);
		/* find closest neighbor and distance */
		if (dDist < p->DEMStats.fDistMin) {
			iClosest = i;
			p->DEMStats.fDistMin = dDist;
			}
		{
			/* overlap statistics for histogram */
			double rn,sr,dOverlap=0.0;
			rn = RADIUS(pn);
			mdlassert(smf->pkd->mdl,rn > 0.0);
			/* avoiding the double count */
			if (rn > r)
				continue; /* skip if neighbor is bigger */
			if (rn == r && pn->iOrder < p->iOrder)
				continue; /* skip if neighbor is equal sized and has smaller iOrder */
			sr = r + rn;
			if (dDist <= sr) {
				/* overlap! */
				dOverlap = (r + rn - dDist)/(2.0*rn);
				if (dOverlap > p->DEMStats.fOverlap) {
					p->DEMStats.fOverlap = dOverlap; /* store if this is indeed the maximum overlap */
					/*if (dOverlap > 0.001) p->iColor = 4;*/ /*DEBUG:HACK TO RECOLOR LARGE OVERLAPS*/
				}
				/* calculate relative speed */
				dVx = p->v[0] - pn->v[0];
				dVy = p->v[1] - pn->v[1];
				dVz = p->v[2] - pn->v[2];
#ifdef SLIDING_PATCH
				if (smf->PP.bPatch) {
					/* adjust neighbor y-velocity if it's a ghost! */
					if (p->r[0] > pn->r[0] && nnList[i].dx < 0.0)
						dVy += 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
					else if (p->r[0] < pn->r[0] && nnList[i].dx > 0.0)
						dVy -= 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
					}
#endif /* SLIDING PATCH */
				dSpeed = sqrt(dVx*dVx + dVy*dVy + dVz*dVz);
				/* find highest relative overlap speed */
				if (dSpeed > p->DEMStats.fSpeedMax)
					p->DEMStats.fSpeedMax = dSpeed;
				}
			}
		}
	/* calculate angle between the position vector and the relative velocity vector between two closest particles */
	pn = nnList[iClosest].pPart;
	/* find cos(alpha) */
	{
		dDist = p->DEMStats.fDistMin;
		if (dDist == 0.0)
			p->DEMStats.fCosA = -DBL_MAX;
		else {
			dVx = p->v[0] - pn->v[0];
			dVy = p->v[1] - pn->v[1];
			dVz = p->v[2] - pn->v[2];
#ifdef SLIDING_PATCH
			if (smf->PP.bPatch) {
				if (p->r[0] > pn->r[0] && nnList[i].dx < 0.0)
					dVy += 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
				else if (p->r[0] < pn->r[0] && nnList[i].dx > 0.0)
					dVy -= 1.5*smf->PP.dOrbFreq*smf->PP.dWidth;
				}
#endif /* SLIDING PATCH */
			dSpeed = sqrt(dVx*dVx + dVy*dVy + dVz*dVz);
			if (dSpeed == 0.0)
				p->DEMStats.fCosA = DBL_MAX;
			else {
				double dRdotV = nnList[iClosest].dx*dVx + nnList[iClosest].dy*dVy + nnList[iClosest].dz*dVz;
				p->DEMStats.fCosA = dRdotV/(dDist*dSpeed);
				}
			}
		}
	/* maximum S vector... */
	{
		DEM_ELEMENT *pe;
		double dS2;
		for (i=0;i<MAX_NUM_OVERLAPS_PER_PARTICLE;i++) {
			pe = &p->overlaps[i];
			if (pe->iOrder != -1) {
				dS2 = vectorMagSq(pe->vShear);
				if (dS2 > p->DEMStats.fS2)
					p->DEMStats.fS2 = dS2;
				}
			}
		}
	}

#endif /* DEM */

#endif /* COLLISIONS */

#ifdef SLIDING_PATCH

void initFindOverlaps(void *p)
{
	((PARTICLE *)p)->dtCol = 0.0;
	}

void combFindOverlaps(void *p1,void *p2)
{
	if (((PARTICLE *)p2)->dtCol < 0.0) ((PARTICLE *)p1)->dtCol = -1.0;
	}

void FindOverlaps(PARTICLE *p,int nSmooth,NN *nnList,SMF *smf)
{
	/*
	 ** Streamlined version of FindRejects() designed specifically
	 ** for the sliding patch when we want to randomize particle
	 ** data following an azimuthal boundary wrap.  As part of the
	 ** randomization procedure, we need to make sure we don't
	 ** overlap any particles.  That's what's checked for here.
	 */

	PARTICLE *pn = NULL;
	double r,rn,sr;
	int i;

	mdlassert(smf->pkd->mdl,nSmooth > 1); /* for now */

	mdlassert(smf->pkd->mdl,p->dtCol >= 0.0); /* can't already be rejected */

	mdlassert(smf->pkd->mdl,p->bAzWrap == 1); /* must have wrapped */

	r = RADIUS(p);

	for (i=0;i<nSmooth;i++) {
		pn = nnList[i].pPart;
		if (pn->iOrder == p->iOrder) continue;
		rn = RADIUS(pn);
		sr = r + rn;
		if (nnList[i].fDist2 <= sr*sr) p->dtCol = -1.0; /* cf REJECT() macro */
	}

	if (p->dtCol >= 0.0) p->bAzWrap = 0; /* if not rejected, do not need to regenerate */
	if (p->bAzWrap) printf("FindOverlaps(): particle %i overlaps particle %i\n",p->iOrder,pn->iOrder);
}
#endif /* SLIDING_PATCH */
